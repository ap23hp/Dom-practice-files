<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="btn">Click Me</button>

    <script>
      const btn = document.getElementById("btn");

      btn.addEventListener("click", (e) => {
        console.log("Button clicked!");
        console.log(e.isTrusted); // true = real click, false = fake click
        console.log("Clicked!", e.clientX, e.clientY);
        console.log("Is real click?", e.isTrusted);
      });

      // 1. Create the event
      let clickEvent = new Event("click");

      // 2. Dispatch it on the button
      btn.dispatchEvent(clickEvent);

      let mouseClick = new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        clientX: 150,
        clientY: 200,
      });
      btn.dispatchEvent(mouseClick);

      //You never clicked the button physically.
      //The code created a "click" event and dispatched it.
      //The event listener ran exactly like a real click.

      // Here’s where they’re used in the real world:

      // 1. Automated Testing
      // When you’re writing unit tests or UI tests, you don’t want to manually click every button.
      // You can simulate a click in code to test if your event handlers work.

      // Example:
      // // In a test file
      // button.dispatchEvent(new MouseEvent("click", { bubbles: true }));
      // expect(button.classList.contains("active")).toBe(true);
      // Saves time and allows tests to run without human interaction.

      // 2. Triggering Actions Automatically
      // Sometimes you want a click to happen as part of a workflow without the user touching the UI.

      // Example:

      // User logs in -> automatically open a modal
      // loginForm.addEventListener("submit", () => {
      //   modalOpenBtn.dispatchEvent(new MouseEvent("click", { bubbles: true }));
      // });
      //Avoids duplicating code — you reuse the same click handler that’s already written for the button.

      // 3. Complex UI Interactions
      // If you have a custom component that responds to clicks
      // (like a dropdown, carousel, or slider), you might simulate clicks to:

      // Move to the next slide automatically.
// Open/close menus at certain times.
// Replay an interaction for a tutorial.

      // Example:

      // // Auto-click "next" button every 5 seconds
      // setInterval(() => {
      //   nextBtn.dispatchEvent(new MouseEvent("click", { bubbles: true }));
      // }, 5000);
      // 4. Accessibility & Keyboard Shortcuts
      // Sometimes keyboard actions (like pressing Enter or Space) should behave the same as a click.
      // Instead of rewriting the same logic twice, the key handler can fake-click the element.

      // Example:

      // document.addEventListener("keydown", (e) => {
      //   if (e.key === "Enter") {
      //     submitBtn.dispatchEvent(new MouseEvent("click", { bubbles: true }));
      //   }
      // });
      // 5. Cross-Component Communication
      // In big apps, one part of the page can “tell” another part to run its
      //  click handler, without having direct access to its internal code.

      //  Important:
      // Browsers block certain fake events for security reasons — for example,
      // you can’t simulate a click that opens the file picker
      //  (<input type="file">) unless it’s triggered by a real user action.

      // First, a real click changes something.
// Then, a fake click triggers the exact same thing automatically.
// That way you’ll actually see how this saves code repetition.
    </script>
  </body>
</html>
